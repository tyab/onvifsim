<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ONVIF Simulator Test Page</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 2em; background-color: #f8f9fa; color: #212529; }
        h1, h2, h3 { color: #343a40; border-bottom: 2px solid #dee2e6; padding-bottom: 0.5em;}
        .container { display: flex; flex-direction: column; gap: 2em; }
        .ptz-container { display: flex; flex-wrap: wrap; gap: 2em; }
        .ptz-controls { flex: 1; min-width: 300px; background-color: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 1em; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); }
        .ptz-grid { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px; gap: 5px; }
        .ptz-grid button { width: 100%; height: 100%; font-size: 1.5em; }
        .zoom-controls { display: flex; flex-direction: column; margin-left: 10px; }
        .other-controls { margin-top: 2em; }
        .service-group { margin-bottom: 1.5em; padding: 1em; background-color: #fff; border-radius: 0.25rem; box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,.075); }
        .service-group button { margin: 5px 2px; }
        #log { border: 1px solid #ced4da; background-color: #fff; padding: 10px; height: 250px; overflow-y: scroll; white-space: pre-wrap; margin-top: 1em; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 13px; border-radius: 0.25rem; }
        input[type=number] { width: 80px; padding: 5px; border: 1px solid #ced4da; border-radius: 0.25rem; }
        .abs-input { margin-bottom: 10px; }
        button { padding: 8px 12px; font-size: 14px; border-radius: 0.25rem; border: 1px solid transparent; cursor: pointer; background-color: #007bff; color: white; }
        button:hover { background-color: #0056b3; }
    </style>
</head>
<body>
    <h1>ONVIF Simulator Test Page</h1>
    <div class="service-group">
        <h2>Target Device</h2>
        <div style="display: flex; align-items: center; gap: 15px;">
            <div>IP Address: <input type="text" id="targetIp" value="{{ server_ip }}" style="width: 150px;"></div>
            <div>Port: <input type="number" id="targetPort" value="{{ soap_port }}" style="width: 80px;"></div>
            <div>Username: <input type="text" id="username" value="admin" style="width: 120px;"></div>
            <div>Password: <input type="password" id="password" value="" style="width: 120px;"></div>
            <div>Endpoint: <input type="text" id="endpointPath" value="onvif/device_service" style="width: 200px;"></div>
        </div>
        <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
            <button onclick="discoverDevices()">Discover Devices</button>
            <select id="discoveredDevices" onchange="selectDevice(this)" style="padding: 5px; min-width: 250px;">
                <option value="">-- Select a discovered device --</option>
            </select>
            <span id="discoverSpinner" style="display: none;">üîç Searching...</span>
        </div>
        <div style="display: flex; align-items: center; gap: 15px; margin-top: 10px;">
            <button onclick="authenticateDevice()">Authenticate</button>
            <div id="authStatus" style="font-weight: bold;">Status: Not Authenticated</div>
        </div>
        <p style="font-size: 0.9em; margin-top: 5px;">„ÉÜ„Çπ„ÉàÂØæË±°„ÅÆONVIF„Éá„Éê„Ç§„ÇπÔºà„Ç∑„Éü„É•„É¨„Éº„Çø„Éº„Åæ„Åü„ÅØÂÆüÊ©üÔºâ„ÅÆIP„Ç¢„Éâ„É¨„Çπ„Å®„Éù„Éº„Éà„ÇíÊåáÂÆö„Åó„Åæ„Åô„ÄÇ</p>
    </div>

    <div class="container">
        <div>
            <h2>PTZ Control</h2>
            <div class="ptz-container">
                <div class="ptz-controls">
                    <h3>Continuous Move</h3>
                    <div style="display: flex;">
                        <div class="ptz-grid">
                            <button onmousedown="ptzContinuousMove(-0.5, 0.5)" onmouseup="ptzStop()">‚Üñ</button>
                            <button onmousedown="ptzContinuousMove(0, 0.5)" onmouseup="ptzStop()">‚Üë</button>
                            <button onmousedown="ptzContinuousMove(0.5, 0.5)" onmouseup="ptzStop()">‚Üó</button>
                            <button onmousedown="ptzContinuousMove(-0.5, 0)" onmouseup="ptzStop()">‚Üê</button>
                            <button onclick="ptzStop()">‚ñ†</button>
                            <button onmousedown="ptzContinuousMove(0.5, 0)" onmouseup="ptzStop()">‚Üí</button>
                            <button onmousedown="ptzContinuousMove(-0.5, -0.5)" onmouseup="ptzStop()">‚Üô</button>
                            <button onmousedown="ptzContinuousMove(0, -0.5)" onmouseup="ptzStop()">‚Üì</button>
                            <button onmousedown="ptzContinuousMove(0.5, -0.5)" onmouseup="ptzStop()">‚Üò</button>
                        </div>
                        <div class="zoom-controls">
                            <button onmousedown="ptzContinuousMove(0, 0, 0.5)" onmouseup="ptzStop()">Zoom In (+)</button>
                            <button onmousedown="ptzContinuousMove(0, 0, -0.5)" onmouseup="ptzStop()">Zoom Out (-)</button>
                        </div>
                    </div>
                </div>

                <div class="ptz-controls">
                    <h3>Absolute Move</h3>
                    <p style="margin-top:0; font-size: 0.9em;">Pan/Tilt: -1.0 to 1.0, Zoom: 0.0 to 1.0</p>
                    <div class="abs-input">Pan: <input type="number" id="panAbs" value="0.0" step="0.1" min="-1.0" max="1.0"></div>
                    <div class="abs-input">Tilt: <input type="number" id="tiltAbs" value="0.0" step="0.1" min="-1.0" max="1.0"></div>
                    <div class="abs-input">Zoom: <input type="number" id="zoomAbs" value="0.0" step="0.1" min="0.0" max="1.0"></div>
                    <button onclick="ptzAbsoluteMove()">Go to Position</button>
                </div>
            </div>
        </div>

        <div class="other-controls">
            <h2>Other ONVIF Commands</h2>
            <div class="service-group">
                <h3>Device & Media</h3>
                <button onclick="sendSoapRequest('device_service', getCapabilitiesBody)">GetCapabilities</button>
                <button onclick="sendSoapRequest('device_service', getDeviceInformationBody)">GetDeviceInformation</button>
                <p style="margin-top: 10px;"><strong>Active Profile Token:</strong> <code id="activeProfileToken">{{ profile_token }}</code></p>
                <button onclick="getStreamUri()">GetStreamUri</button>
                {% if rtsp_url %}
                <p style="margin-top: 10px;"><strong>Simulator's RTSP URL:</strong> <code>{{ rtsp_url }}</code></p>
                {% endif %}
            </div>
            <div class="service-group">
                <h3>PTZ & Imaging</h3>
                <button onclick="sendSoapRequest('ptz_service', getNodesBody)">GetNodes</button>
                <button onclick="getStatus()">GetStatus</button>
                <button onclick="sendSoapRequest('imaging_service', getImagingSettingsBody)">GetImagingSettings</button>
            </div>
            <div class="service-group">
                <h3>Events</h3>
                <button onclick="sendSoapRequest('events_service', createPullPointSubscriptionBody)">CreatePullPointSubscription</button>
                <button onclick="sendSoapRequest('events/pullpoint', pullMessagesBody)">PullMessages (Single)</button>
                <button id="pullToggleBtn" onclick="togglePullingMessages()">Start Pulling Events</button>
                <span id="pullStatus" style="margin-left: 10px;"></span>
            </div>
        </div>

        <div>
            <h2>Log</h2>
            <div id="log"></div>
        </div>
    </div>

    <script>
        const protocol = '{{ protocol }}';
        const initialProfileToken = '{{ profile_token }}';
        let profileToken = initialProfileToken; // Use let to allow modification
        const videoSourceToken = '{{ video_source_token }}';
        const logDiv = document.getElementById('log');
        let pullIntervalId = null;


        // --- SOAP Body Templates ---
        const getCapabilitiesBody = `<tds:GetCapabilities><tds:Category>All</tds:Category></tds:GetCapabilities>`;
        const getDeviceInformationBody = `<tds:GetDeviceInformation/>`;
        const getProfilesBody = `<trt:GetProfiles/>`;
        const getStreamUriBody = () => `<trt:GetStreamUri><trt:StreamSetup><tt:Stream>RTP-Unicast</tt:Stream><tt:Transport><tt:Protocol>RTSP</tt:Protocol></tt:Transport></trt:StreamSetup><trt:ProfileToken>${profileToken}</trt:ProfileToken></trt:GetStreamUri>`;
        const getNodesBody = `<tptz:GetNodes/>`;
        const getStatusBody = () => `<tptz:GetStatus><tptz:ProfileToken>${profileToken}</tptz:ProfileToken></tptz:GetStatus>`;
        const getImagingSettingsBody = `<timg:GetImagingSettings><timg:VideoSourceToken>${videoSourceToken}</timg:VideoSourceToken></timg:GetImagingSettings>`;
        const createPullPointSubscriptionBody = `<tev:CreatePullPointSubscription><tev:InitialTerminationTime>PT60S</tev:InitialTerminationTime></tev:CreatePullPointSubscription>`;
        const pullMessagesBody = `<tev:PullMessages><tev:Timeout>PT30S</tev:Timeout><tev:MessageLimit>10</tev:MessageLimit></tev:PullMessages>`;

        function log(message) {
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML = `[${time}] ${message}\n` + logDiv.innerHTML;
        }

        async function discoverDevices() {
            const discoverBtn = document.querySelector('button[onclick="discoverDevices()"]');
            const spinner = document.getElementById('discoverSpinner');
            const devicesSelect = document.getElementById('discoveredDevices');

            discoverBtn.disabled = true;
            spinner.style.display = 'inline';
            devicesSelect.innerHTML = '<option value="">-- Searching... --</option>';
            log('Starting device discovery...');

            try {
                const response = await fetch('/discover');
                if (!response.ok) {
                    throw new Error(`Discovery failed with status: ${response.status}`);
                }
                const devices = await response.json();

                devicesSelect.innerHTML = '<option value="">-- Select a discovered device --</option>';
                if (devices.length > 0) {
                    devices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = `${device.ip}:${device.port}`;
                        option.textContent = `${device.name} (${device.ip}:${device.port})`;
                        devicesSelect.appendChild(option);
                    });
                    log(`Discovery finished. Found ${devices.length} device(s).`);
                } else {
                    log('Discovery finished. No devices found.');
                    devicesSelect.innerHTML = '<option value="">-- No devices found --</option>';
                }
            } catch (error) {
                log(`Error during discovery: ${error}`);
                console.error('Discovery error:', error);
                devicesSelect.innerHTML = '<option value="">-- Discovery failed --</option>';
            } finally {
                discoverBtn.disabled = false;
                spinner.style.display = 'none';
            }
        }

        function selectDevice(selectElement) {
            const [ip, port] = selectElement.value.split(':');
            document.getElementById('targetIp').value = ip || '{{ server_ip }}';
            document.getElementById('targetPort').value = port || '{{ soap_port }}';
        }

        async function ensureProfileToken() {
            // Ë™çË®ºÊ∏à„Åø„Åß„ÄÅ„Åã„Å§„Éà„Éº„ÇØ„É≥„ÅåÂàùÊúüÂÄ§„ÅÆÂ†¥Âêà„ÅÆ„ÅøÂèñÂæó
            if (document.getElementById('authStatus').textContent.includes('Authenticated') && profileToken === initialProfileToken) {
                log("Profile token is not set. Fetching automatically...");
                await getAndUseProfileToken();
            }
        }

        async function ptzContinuousMove(panSpeed, tiltSpeed, zoomSpeed = 0) {
            await ensureProfileToken();
            const body = `
<tptz:ContinuousMove>
    <tptz:ProfileToken>${profileToken}</tptz:ProfileToken>
    <tptz:Velocity>
        <tt:PanTilt x="${panSpeed}" y="${tiltSpeed}" />
        <tt:Zoom x="${zoomSpeed}" />
    </tptz:Velocity>
</tptz:ContinuousMove>
            `;
            sendSoapRequest('ptz_service', body);
        }

        async function ptzStop() {
            await ensureProfileToken();
            const body = `
<tptz:Stop>
    <tptz:ProfileToken>${profileToken}</tptz:ProfileToken>
    <tptz:PanTilt>true</tptz:PanTilt>
    <tptz:Zoom>true</tptz:Zoom>
</tptz:Stop>
            `;
            sendSoapRequest('ptz_service', body);
        }

        async function ptzAbsoluteMove() {
            await ensureProfileToken();
            const pan = document.getElementById('panAbs').value;
            const tilt = document.getElementById('tiltAbs').value;
            const zoom = document.getElementById('zoomAbs').value;

            const body = `
<tptz:AbsoluteMove>
    <tptz:ProfileToken>${profileToken}</tptz:ProfileToken>
    <tptz:Position>
        <tt:PanTilt x="${pan}" y="${tilt}" />
        <tt:Zoom x="${zoom}" />
    </tptz:Position>
</tptz:AbsoluteMove>
            `;
            sendSoapRequest('ptz_service', body);
        }

        async function getAndUseProfileToken() {
            log("Attempting to get profiles... (This requires authentication)");
            const responseText = await sendSoapRequest('media_service', getProfilesBody);
            if (!responseText) {
                log("Failed to get profiles. Profile token not updated.");
                return;
            }

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(responseText, "text/xml");
                const profileElement = xmlDoc.getElementsByTagName("trt:Profiles")[0];
                const token = profileElement.getAttribute("token");
                if (token) {
                    profileToken = token;
                    document.getElementById('activeProfileToken').textContent = token;
                    log(`Successfully updated profile token to: ${token}`);
                } else {
                    log("Could not find profile token in the response.");
                }
            } catch (e) {
                log(`Error parsing GetProfiles response: ${e}`);
            }
        }

        async function getStreamUri() {
            await ensureProfileToken();
            sendSoapRequest('media_service', getStreamUriBody());
        }

        async function getStatus() {
            await ensureProfileToken();
            sendSoapRequest('ptz_service', getStatusBody());
        }

        async function authenticateDevice() {
            const authStatusDiv = document.getElementById('authStatus');
            authStatusDiv.textContent = 'Status: Authenticating...';
            authStatusDiv.style.color = 'orange';

            // GetDeviceInformation„ÇíÈÄÅ‰ø°„Åó„Å¶Ë™çË®º„ÇíË©¶„Åø„Çã
            const responseText = await sendSoapRequest('device_service', getDeviceInformationBody);
            const success = responseText && !responseText.includes("Fault");
            authStatusDiv.textContent = success ? 'Status: Authenticated' : 'Status: Authentication Succeeded (but check logs for faults)';
            authStatusDiv.style.color = success ? 'green' : 'red';
        }

        // „Ç´„É°„É©„ÅÆÊôÇÂàª„Çí‰øùÊåÅ„Åô„Çã„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        let cameraTime = null;
        let cameraTimeFetchedAt = 0;

        async function getCameraTime() {
            // 10ÂàÜ‰ª•ÂÜÖ„Å´ÂèñÂæó„Åó„Å¶„ÅÑ„Çå„Å∞„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíËøî„Åô
            if (cameraTime && (Date.now() - cameraTimeFetchedAt < 600000)) {
                // ÁµåÈÅéÊôÇÈñìÂàÜ„Å†„ÅëÊôÇÂàª„ÇíÈÄ≤„ÇÅ„Çã
                const elapsedMs = Date.now() - cameraTimeFetchedAt;
                return new Date(cameraTime.getTime() + elapsedMs);
            }

            log("Fetching current time from camera for accurate authentication...");
            const getTimeBody = `<tds:GetSystemDateAndTime/>`;
            // GetSystemDateAndTime„ÅØË™çË®º„Å™„Åó„Åß„É™„ÇØ„Ç®„Çπ„Éà„ÇíÈÄÅ‰ø°
            const responseText = await sendSoapRequest('device_service', getTimeBody, true); // skipAuthHeader„Éï„É©„Ç∞„Çítrue„Å´Ë®≠ÂÆö
            if (!responseText) {
                log("Failed to get camera time. Using local time as fallback.");
                return new Date(); // Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØ„É≠„Éº„Ç´„É´ÊôÇÂàª
            }

            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(responseText, "text/xml");
                const year = xmlDoc.getElementsByTagName("tt:Year")[0].childNodes[0].nodeValue;
                const month = xmlDoc.getElementsByTagName("tt:Month")[0].childNodes[0].nodeValue;
                const day = xmlDoc.getElementsByTagName("tt:Day")[0].childNodes[0].nodeValue;
                const hour = xmlDoc.getElementsByTagName("tt:Hour")[0].childNodes[0].nodeValue;
                const minute = xmlDoc.getElementsByTagName("tt:Minute")[0].childNodes[0].nodeValue;
                const second = xmlDoc.getElementsByTagName("tt:Second")[0].childNodes[0].nodeValue;
                
                cameraTime = new Date(Date.UTC(year, month - 1, day, hour, minute, second));
                cameraTimeFetchedAt = Date.now();
                log(`Camera time synchronized: ${cameraTime.toISOString()}`);
                return cameraTime;
            } catch (e) {
                log(`Error parsing camera time: ${e}. Using local time.`);
                return new Date();
            }
        }

        async function generateWSSecurityHeader(service, body) {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            // „É¶„Éº„Ç∂„ÉºÂêç„Åå„Å™„ÅÑ„ÄÅ„Åæ„Åü„ÅØË™çË®º‰∏çË¶Å„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂ†¥Âêà„ÅØ„Éò„ÉÉ„ÉÄ„Éº„ÇíÁîüÊàê„Åó„Å™„ÅÑ
            const unauthenticatedActions = ['GetCapabilities']; // GetSystemDateAndTime„ÅØ„Åì„Åì„ÅßÂà§ÂÆö„Åô„ÇãÂøÖË¶Å„Åå„Å™„Åè„Å™„Çã
            const actionMatch = body.match(/<(?:\w+:)?([^> ]+)/);
            const action = actionMatch ? actionMatch[1] : '';

            // „É¶„Éº„Ç∂„ÉºÂêç„ÅåÁ©∫„ÄÅ„Åæ„Åü„ÅØË™çË®º‰∏çË¶Å„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ„É™„Çπ„Éà„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Éò„ÉÉ„ÉÄ„Éº„ÇíÁîüÊàê„Åó„Å™„ÅÑ
            if (!username || unauthenticatedActions.includes(action) ) {
                return ''; // „É¶„Éº„Ç∂„ÉºÂêç„Åå„Å™„Åë„Çå„Å∞Ë™çË®º„Éò„ÉÉ„ÉÄ„Éº„Å™„Åó
            }

            // „Ç´„É°„É©„ÅÆÊôÇÂàª„ÇíÂèñÂæó„Åó„Å¶‰ΩøÁî®
            const createdDate = await getCameraTime();
            const created = createdDate.toISOString();
            
            // 1. Nonce„ÅÆÁîüÊàê (16„Éê„Ç§„Éà„ÅÆ„É©„É≥„ÉÄ„É†ÂÄ§)
            const nonceBytes = new Uint8Array(16);
            window.crypto.getRandomValues(nonceBytes);
            const nonceBase64 = btoa(String.fromCharCode.apply(null, nonceBytes));

            // 2. Digest„ÅÆË®àÁÆó (SHA-1)
            // Digest = Base64(SHA1(Nonce + Created + Password))
            const encoder = new TextEncoder();
            const passwordBytes = encoder.encode(password);
            const createdBytes = encoder.encode(created);
            
            const combined = new Uint8Array(nonceBytes.length + createdBytes.length + passwordBytes.length);
            combined.set(nonceBytes, 0);
            combined.set(createdBytes, nonceBytes.length);
            combined.set(passwordBytes, nonceBytes.length + createdBytes.length);

            const digestBuffer = await window.crypto.subtle.digest('SHA-1', combined);
            const digestBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(digestBuffer)));

            return `
<wsse:Security>
    <wsse:UsernameToken>
        <wsse:Username>${username}</wsse:Username>
        <wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">${digestBase64}</wsse:Password>
        <wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">${nonceBase64}</wsse:Nonce>
        <wsu:Created>${created}</wsu:Created>
    </wsse:UsernameToken>
</wsse:Security>`;
        }

        async function sendSoapRequest(service, body, skipAuthHeader = false) {
            const targetIp = document.getElementById('targetIp').value;
            const targetPort = document.getElementById('targetPort').value;
            let endpointPath = document.getElementById('endpointPath').value;
            if (!targetIp || !targetPort || !endpointPath) {
                alert('Target IP, Port, and Endpoint must be specified.');
                return null;
            }
            endpointPath = endpointPath.replace('device_service', service);
            const proxyPort = 8081;
            const url = `http://${window.location.hostname}:${proxyPort}/proxy/${endpointPath}?target_ip=${targetIp}&target_port=${targetPort}`;
            
            // skipAuthHeader„Éï„É©„Ç∞„Ååtrue„ÅÆÂ†¥Âêà„ÄÅË™çË®º„Éò„ÉÉ„ÉÄ„Éº„ÅÆÁîüÊàê„Çí„Çπ„Ç≠„ÉÉ„Éó„Åô„Çã
            const securityHeader = skipAuthHeader ? '' : await generateWSSecurityHeader(service, body);

            // --- Dynamic Namespace Generation ---
            // Switch to SOAP 1.1, as some cameras are stricter and may fail with SOAP 1.2.
            const namespaces = {
                'soap-env': "http://schemas.xmlsoap.org/soap/envelope/", // SOAP 1.1
                'tt': "http://www.onvif.org/ver10/schema"
            };
            if (securityHeader) {
                namespaces['wsse'] = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
                namespaces['wsu'] = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
            }
            // Add namespaces based on prefixes found in the body
            const bodyPrefixes = (body.match(/<(\w+):/g) || []).map(p => p.substring(1, p.length - 1));
            const serviceNamespaces = {
                'tds': "http://www.onvif.org/ver10/device/wsdl",
                'trt': "http://www.onvif.org/ver10/media/wsdl",
                'tptz': "http://www.onvif.org/ver20/ptz/wsdl",
                'timg': "http://www.onvif.org/ver20/imaging/wsdl",
                'tev': "http://www.onvif.org/ver10/events/wsdl",
                'wsnt': "http://docs.oasis-open.org/wsn/b-2"
            };
            bodyPrefixes.forEach(prefix => {
                if (serviceNamespaces[prefix]) namespaces[prefix] = serviceNamespaces[prefix];
            });
            const namespaceString = Object.entries(namespaces).map(([key, value]) => `xmlns:${key}="${value}"`).join('\n    ');

            // --- SOAPAction Header for SOAP 1.1 ---
            const actionMatch = body.match(/<(?:\w+:)?([^> ]+)/);
            const action = actionMatch ? actionMatch[1] : '';
            const serviceUrls = {
                'device_service': 'http://www.onvif.org/ver10/device/wsdl',
                'media_service': 'http://www.onvif.org/ver10/media/wsdl',
                'ptz_service': 'http://www.onvif.org/ver20/ptz/wsdl',
                'imaging_service': 'http://www.onvif.org/ver20/imaging/wsdl',
                'events_service': 'http://www.onvif.org/ver10/events/wsdl',
                'events/pullpoint': 'http://www.onvif.org/ver10/events/wsdl/PullPoint'
            };
            let soapAction = "";
            if (serviceUrls[service] && action) {
                soapAction = `"${serviceUrls[service]}/${action}"`;
            }

            // „Éò„ÉÉ„ÉÄ„Éº„ÅåÁ©∫„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„ÄÅHeader„Çø„Ç∞„Åß„É©„ÉÉ„Éó„Åô„Çã
            const soapHeader = securityHeader ? `<soap-env:Header>${securityHeader}</soap-env:Header>` : '';

            const soapEnvelope = `
<soap-env:Envelope ${namespaceString}>
    ${soapHeader}
    <soap-env:Body>${body}</soap-env:Body>
</soap-env:Envelope>
            `;
            log(`Request to ${url}:\n${soapEnvelope.trim().replace(/\s+/g, ' ')}`);

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/xml; charset=utf-8', // SOAP 1.1
                        'SOAPAction': soapAction
                    },
                    body: soapEnvelope.trim()
                });
                const text = await response.text();
                if (!response.ok) {
                    log(`HTTP error! status: ${response.status}, body: ${text}`);
                }
                log(`Response from ${endpointPath}:\n${text.trim().replace(/\s+/g, ' ')}`);
                return text; // „É¨„Çπ„Éù„É≥„Çπ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíËøî„Åô
            } catch (error) {
                log(`Error: ${error}`);
                console.error('Fetch error:', error);
                return null; // Â§±ÊïóÊôÇ„Å´null„ÇíËøî„Åô
            }
        }

        function togglePullingMessages() {
            const pullBtn = document.getElementById('pullToggleBtn');
            const pullStatus = document.getElementById('pullStatus');

            if (pullIntervalId) {
                // Stop pulling
                clearInterval(pullIntervalId);
                pullIntervalId = null;
                pullBtn.textContent = 'Start Pulling Events';
                pullBtn.style.backgroundColor = '#007bff';
                pullStatus.textContent = 'Stopped.';
            } else {
                // Start pulling
                sendSoapRequest('events/pullpoint', pullMessagesBody); // Pull immediately
                pullIntervalId = setInterval(() => sendSoapRequest('events/pullpoint', pullMessagesBody), 5000); // Pull every 5 seconds
                pullBtn.textContent = 'Stop Pulling Events';
                pullBtn.style.backgroundColor = '#dc3545';
                pullStatus.textContent = 'Polling every 5s...';
            }
        }
    </script>
</body>
</html>